# coding: utf-8

"""
    VxRail REST API

    The VxRail REST API provides a programmatic interface for performing VxRail administrative tasks. Data is available in JSON format.  # noqa: E501

    OpenAPI spec version: 3.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from vxrail_ansible_utility.api_client import ApiClient


class SupportLogsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def v1_support_logs_get(self, **kwargs):  # noqa: E501
        """Query all of support logs  # noqa: E501

        Query all of the support logs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_support_logs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Query conditions for the support logs are Equal(eq), and not equal(ne). Supported fields are id, path, types, and nodes. In addition, types and nodes are collection condition fields, which means the value is equal though the sequence is different. For example, 'node1, node2, node3' is equal to 'node3, node2, node1'. Example: $filter=id eq 'VxRail_Support_Bundle_52fd1cfc-4646-8a7d-d4ba-721c3da3808e_2018_10_08_08_30_44 and nodes eq 'node1, node2, node3'
        :return: list[LogInfoV2]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_support_logs_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_support_logs_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_support_logs_get_with_http_info(self, **kwargs):  # noqa: E501
        """Query all of support logs  # noqa: E501

        Query all of the support logs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_support_logs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Query conditions for the support logs are Equal(eq), and not equal(ne). Supported fields are id, path, types, and nodes. In addition, types and nodes are collection condition fields, which means the value is equal though the sequence is different. For example, 'node1, node2, node3' is equal to 'node3, node2, node1'. Example: $filter=id eq 'VxRail_Support_Bundle_52fd1cfc-4646-8a7d-d4ba-721c3da3808e_2018_10_08_08_30_44 and nodes eq 'node1, node2, node3'
        :return: list[LogInfoV2]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_support_logs_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter' in params:
            query_params.append(('$filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/support/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LogInfoV2]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_support_logs_id_download_get(self, log_id, **kwargs):  # noqa: E501
        """Download the binary stream of a log  # noqa: E501

        Download the binary stream of a log.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_support_logs_id_download_get(log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str log_id: The unique identifier of the log that you want to download. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_support_logs_id_download_get_with_http_info(log_id, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_support_logs_id_download_get_with_http_info(log_id, **kwargs)  # noqa: E501
            return data

    def v1_support_logs_id_download_get_with_http_info(self, log_id, **kwargs):  # noqa: E501
        """Download the binary stream of a log  # noqa: E501

        Download the binary stream of a log.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_support_logs_id_download_get_with_http_info(log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str log_id: The unique identifier of the log that you want to download. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['log_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_support_logs_id_download_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'log_id' is set
        if ('log_id' not in params or
                params['log_id'] is None):
            raise ValueError("Missing the required parameter `log_id` when calling `v1_support_logs_id_download_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'log_id' in params:
            path_params['logId'] = params['log_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/support/logs/{logId}/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_support_logs_id_get(self, log_id, **kwargs):  # noqa: E501
        """Query the log by the log ID  # noqa: E501

        Query the log by the log ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_support_logs_id_get(log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str log_id: The log ID (required)
        :return: LogInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_support_logs_id_get_with_http_info(log_id, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_support_logs_id_get_with_http_info(log_id, **kwargs)  # noqa: E501
            return data

    def v1_support_logs_id_get_with_http_info(self, log_id, **kwargs):  # noqa: E501
        """Query the log by the log ID  # noqa: E501

        Query the log by the log ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_support_logs_id_get_with_http_info(log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str log_id: The log ID (required)
        :return: LogInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['log_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_support_logs_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'log_id' is set
        if ('log_id' not in params or
                params['log_id'] is None):
            raise ValueError("Missing the required parameter `log_id` when calling `v1_support_logs_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'log_id' in params:
            path_params['logId'] = params['log_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/support/logs/{logId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_support_logs_post(self, body, **kwargs):  # noqa: E501
        """Collect the support log with the specified types of components  # noqa: E501

        Collect the support log with the specified types of components.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_support_logs_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogSpecV2 body: The specified types and nodes for the log bundle collection. (required)
        :return: InlineResponse202
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_support_logs_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_support_logs_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def v1_support_logs_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Collect the support log with the specified types of components  # noqa: E501

        Collect the support log with the specified types of components.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_support_logs_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogSpecV2 body: The specified types and nodes for the log bundle collection. (required)
        :return: InlineResponse202
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_support_logs_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `v1_support_logs_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/support/logs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse202',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
